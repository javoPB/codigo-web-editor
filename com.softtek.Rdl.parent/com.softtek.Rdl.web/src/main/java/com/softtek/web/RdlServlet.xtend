/*
 * generated by Xtext 2.16.0
 */
package com.softtek.web

import java.io.IOException
import javax.servlet.ServletException
import javax.servlet.annotation.WebServlet
import javax.servlet.http.HttpServletRequest
import javax.servlet.http.HttpServletResponse
import org.apache.log4j.Logger
import org.eclipse.xtext.resource.IResourceServiceProvider
import org.eclipse.xtext.util.DisposableRegistry
import org.eclipse.xtext.web.server.InvalidRequestException
import org.eclipse.xtext.web.server.InvalidRequestException.InvalidDocumentStateException
import org.eclipse.xtext.web.server.InvalidRequestException.PermissionDeniedException
import org.eclipse.xtext.web.server.InvalidRequestException.ResourceNotFoundException
import org.eclipse.xtext.web.servlet.HttpServiceContext
import org.eclipse.xtext.web.servlet.XtextServlet
import com.softtek.web.util.UtilGIT
import java.io.File
import java.util.Calendar

/**
 * Deploy this class into a servlet container to enable DSL-specific services.
 */
@WebServlet(name = 'XtextServices', urlPatterns = '/xtext-service/*')
class RdlServlet extends XtextServlet {	
	
	DisposableRegistry disposableRegistry
	val logg = Logger.getLogger(class);
	
	val serviceProviderRegistry = IResourceServiceProvider.Registry.INSTANCE
	
	override init() {
		super.init()
		val injector = new RdlWebSetup().createInjectorAndDoEMFRegistration();
		disposableRegistry = injector.getInstance(DisposableRegistry);

		println('Hi Homer');
		logg.info('Ejecutando RdlServlet.init()...');
		println("injector: " + injector);
		println("disposableRegistry: " + disposableRegistry);
	}
	
	override destroy() {
		if (disposableRegistry !== null) {
			disposableRegistry.dispose()
			disposableRegistry = null
		}
		super.destroy()
	}

	override protected service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {		
		val String pathDirectoryProject = File.separator+"src"+File.separator+"rdl-directory";
		val String pathLogFile = File.separator+"src"+File.separator+"logs"+File.separator+"log-"+Calendar.getInstance().getTimeInMillis()+".txt";							

		try {
			super.service(req, resp)
			
			val serviceContext = new HttpServiceContext(req)
			val String action = serviceContext.getParameter('job');
			val resource = serviceContext.getParameter('resource');

			if( !action.isNullOrEmpty && action.equals('clone') ){
				val String urlClone = serviceContext.getParameter('urlclone');
				
				val String msgClone = new UtilGIT().executorClone(urlClone, pathDirectoryProject, pathLogFile);
				
				resp.contentType = 'text/plain';
				resp.writer.write("myInit"+msgClone);

				println("Finalizando la clonacion del proyecto...");
			}else if( !action.isNullOrEmpty &&  action.equals('push') ){
				println('Iniciando git-push...')
				
				val String urlClone = serviceContext.getParameter('urlclone');
				val String email = "javier.perezb@softtek.com";
				val String user = serviceContext.getParameter('user');
				val String pass = serviceContext.getParameter('password');

				val String msgPush = new UtilGIT().executorPush(pathDirectoryProject, pathLogFile, urlClone, email, user, pass);
								
				resp.contentType = 'text/plain';
				resp.writer.write("myInit"+msgPush);
				
				println('Finalizando git-push...')
			}else if(  !action.isNullOrEmpty &&  action.equals('refresh') ){
				println('Iniciando refresh...')
				
				val String urlClone = serviceContext.getParameter('urlclone');
				val String msgRefresh = new UtilGIT().executorRefresh(urlClone, pathDirectoryProject, pathLogFile);
				
				resp.contentType = 'text/plain';
				resp.writer.write("myInit"+msgRefresh);
				
				println('Finalizando refresh...')
			}else if( !action.isNullOrEmpty && action.equals('uploadfile') ){
				val String pathFile = req.getParameter("pathfile")
				println('Iniciando upload file... pathFile: ' + pathFile);
				val String contentFile = new UtilGIT().uploaderFile(pathDirectoryProject, pathFile);
				println('Finalizando upload file...');
					
				resp.contentType = 'text/plain'
				resp.writer.write("myInit"+contentFile);
			}else if( !action.isNullOrEmpty && action.equals('markUploadSelectedFile') ){
				println("Iniciando markUploadSelectedFile...")
				val String pathFile = req.getParameter("pathfile")
				val String treeView = new UtilGIT().uploadTreeView(pathDirectoryProject, null, pathFile);
				println("Finalizando markUploadSelectedFile...")
				
				resp.contentType = 'text/plain'
				resp.writer.write("myInit"+treeView);
			}else if( !action.isNullOrEmpty &&  action.equals('save') ){
				val String pathFile = serviceContext.getParameter('pathfile');
				val String isNewRdl = serviceContext.getParameter('isNewRdl');
				val data = serviceContext.getParameter('fullText');
				
				val String treeView = new UtilGIT().saveFile(pathFile, data, pathDirectoryProject, isNewRdl);
				
				resp.contentType = 'text/plain'
				resp.writer.write("myInit"+treeView);
			}else if( !action.isNullOrEmpty &&  action.equals('load') ){
					println("INVOCANDO METODO LOAD...");
			}/*else{
				println('Action undefined...');
			}*/
		} catch (ResourceNotFoundException exception) {
			logg.trace('Invalid request (' + req.requestURI + '): ' + exception.message)
			resp.sendError(HttpServletResponse.SC_NOT_FOUND, exception.message)
		} catch (InvalidDocumentStateException exception) {
			logg.trace('Invalid request (' + req.requestURI + '): ' + exception.message)
			resp.sendError(HttpServletResponse.SC_CONFLICT, exception.message)
		} catch (PermissionDeniedException exception) {
			logg.trace('Invalid request (' + req.requestURI + '): ' + exception.message)
			resp.sendError(HttpServletResponse.SC_FORBIDDEN, exception.message)
		} catch (InvalidRequestException exception) {
			logg.trace('Invalid request (' + req.requestURI + '): ' + exception.message)
			resp.sendError(HttpServletResponse.SC_BAD_REQUEST, exception.message)
		} catch( Exception exception ){
			logg.trace('Invalid request (' + req.requestURI + '): ' + exception.message)
		}		
	}
	
}